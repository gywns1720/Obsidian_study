
# 기초지식
---
## 서버 간 통신
- 어떤 포털 사이트를 하나의 서비스 단위로 개발했다고 과정했을 때 블러그, 카페, 메일 등 기능들을 하나의 에플리케이션으로 통합했다는 뜻이다.
- 서비스를 이렇게 구성하면 서버를 업데이트 하거나 애플리케이션을 유지보수 할 때 마다 '서비스 작업 중' 이라는 팻말을 걸고 작업해야 합니다. 
  그 만큼 개발에 보수적인 입장을 취할 수 없고, 서비스 자체의 규모도 커지기 때문에 서비스를 구동하는데 걸리는 시간도 길어집니다.

- 이 같은 문제를 해결하기 위해 나온 것이 **마이크로서비스 아키텍쳐** 입니다.
- 마이크로서비스 아키텍쳐는 단어 그대로 서비스 규모를 작게 나누어 구성한 아키텍쳐를 뜻합니다.
- 예를 들어 포털 사이트에 마이크로서비스 아키텍쳐를 적용한다면 에플리케이션 하나에 여러 기능을 넣어 개발하지 않고 블로그 프로젝트, 카페 프로젝트, 메일 프로젝트 등 애플리케이션 을 기능별로 나눠서 개발하게 됩니다.

- 단일 서비스 아키텍쳐와 마이크로서비스 아키텍쳐의 구성은 이런식으로 나옵니다.
  ![[Pasted image 20230724125748.png]]

  - 단일 서비스로 구성된 A 포털 사이트는 내부 메서드 호출 등을 통해 원하는 자원을 가져와 사용할 수 있지만 서비스 기능별로 구분해서 B 포털 사이트와 같이 독립적인 애플리케이션을 개발하게 되면 각 서비스 간에 통신해야 하는 경우가 발생합니다.
  - 사용자 블로그 기능을 사용하기 위해 로그인 서비스를 거쳐야만 하는 상황 등이 있겠습니다. 
  - 이런 상황에서 통신을 '서버 간 통신' 이라고 합니다.


- 서버 간 통신은 한 서버가 다른 서버에 통신을 요청하는 것을 의미하며, 한 대는 서버, 다른 한 대는 클라이언트가 되는 구조 입니다.
- 몇 가지 프로토콜에 의해 다양한 통신 방식을 적용할 수 있지만 가장 많이 사용되는 방식은 HTTP/HTTPS 방식입니다.

## 스프링 부트 동작 방식

- 스프링 부트에서 `Spring-boot-starter-web` 모듈을 사용하면 기본적으로 톰켓을 사용하는 스프링 MVC 구조를 기반으로 동작합니다.
- 일반적인 웹 요청이 들어왔을 때의 스프링 부트의 동작 구조입니다.
![[스프링부트 구조.png]]

- 서블릿은 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술 입니다.
- 일반적으로 서블릿은 **서블릿 컨테이너**에서 관리합니다.
- 서블릿 컨테이너
	- 서블릿 인스턴스를 생성하고 관리하는 역활을 수행하는 주체로서 톰켓은 WAS의 역활과 서블릿 컨테이너의 역활을 수행하는 대표적인 컨테이너 입니다.
	- **특징**
		- 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리합니다.
		- 서블릿 객체는 싱글톤 패턴으로 관리합니다.
		- 멀티 스레딩을 지원합니다.
- 스프링에서는 DispatcherServlet 서블릿 역활을 수행합니다.
- 일반적으로 스프링은 톰켓을 임베드해 사용합니다.
- 서블릿 컨테이너와 DispatcherServlet은 자동 설정된 `web.xml` 설정값을 공유합니다.

1. DispatcherServlet 으로 HttpServletRequest 요청이 들어오면 DispatcherServlet 은 핸들러 매핑을 통해 URI 에 매핑된 핸들러를 탐색합니다.  (이것을 핸들러는 컨트롤러를 의미합니다.)
2. 핸들러 어뎁터로 컨트롤러를 호출합니다.
3. 핸들러 어뎁터에 컨트롤러의 응답이 돌아오면 ModelAndView 로 응답을 가공해 반환합니다.
4. 뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버 (View Resolver) 를 통해 View 를 받아 리턴합니다.

핸들러 매핑은 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스 입니다.
핸들러 매핑 인터페이스는 어떤 구현체를 가지며, 대표적인 구현체 클래스는 다음과 같습니다.
1. BeanNameUrlHandlerMapping
	- Bean 이름을 URL로 사용하는 매핑 전략입니다.
	- Bean 을 정의할 때 슬래쉬가 들어가면 매핑 대상이 됩니다.
	- example) `@Bean("/hello")`
2. ControllerClassNameHandlerMapping
	- URL 과 일치하는 클래스 이름을 갖는 Bean을 컨트롤러로 사용하는 전략
	- 이름 중 Controller 를 제외하고 앞부분 작성된 suffix 를 소문자로 매핑한다.
3. SimpleUrlHandlerMapping
	- URL 패턴에 매핑된 컨트롤러를 사용하는 전략
4. DefaultAnnotationHandlerMapping
	- 어노테이션으로 URL과 컨트롤러를 매핑하는 방법 

- 뷰 리졸버는 뷰 렌더링 역활을 담당하는 뷰 객체를 반환한다.
**뷰를 사용하는 DispatcherServlet 동작 방식**
![[Pasted image 20230724131234.png]]

**@RestController 를 사용하는 DispatcherServlet  동작 방식**
![[Pasted image 20230724131340.png]]

## 레이어드 아키텍쳐

- Layered Architecture 란 에플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조를 의미합니다.
- 레이어드 아키텍쳐는 여러 방면에서 쓰이는 개념이며, 어떻게 설계하느냐에 따라 용어와 계층 수가 달라집니다.
- 일방적으로 레이어드 아키텍쳐라 하면 3계층 또는 4계층 구성을 의미합니다.
- 이 차이는 인프라(Data Base) 레이어의 추가 여부로 결정됩니다.

3계층으로 이루워진 레이어드 아키텍쳐
![[Pasted image 20230724143817.png]]
### 프레젠테이션 계층
- 애플리케이션 최상단 계층으로, 클라이언트의 요청을 해석하고 응답하는 역활
- UI 나 API를 제공합니다.

### 비즈니스 계층 
- 애플리케이션이 제공하는 기능을 정의하고 세부 작업을 수행하는 동안 도메인 객체를 통해 업무를 위임하는 역활을 수행합니다.
- DDD (Domain-Driven Design) 기반의 아키텍쳐는 비즈니스 로직에 도메인이 포함되기도 하고, 별도의 도메인 계층을 두기도 합니다.

### 데이터 접근 계층 
- 데이터 베이스에 접근하는 일련의 작업을 수행합니다.


- 레이어드 아키텍쳐는 하나의 애플리케이션에도 적용되지만 애플케이션 간의 관계를 설명하는 데도 사용할 수 있습니다.
- 레이어드 아키텍쳐 기반 설계는 다음과 같은 특징을 가집니다.
	- 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입받습니다.
	- 각 레이어는 관심사에 따라 묶여 있으며, 다른 레이어의 역활을 침범하지 않습니다.
		- 각 컴포넌트의 역활이 명확하므로 코드의 가독성과 기능 구현에 유리합니다.
		- 코드의 확장성도 좋아집니다.
	- 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성을 낮춰 단위 테스트에 용이합니다.
---
### 스프링의 레이어드 아키텍쳐
![[Pasted image 20230724144329.png]]
- Spring MVC 는 Model-View-Controller 구조로 View 와 Controller 는 프레젠테이션 계층 영역이며, Model 은 비즈니스와 데이터 접근 계층의 영역으로 구분할 수 있습니다.

- 스프링 MVC 모델로 레이어드 아키텍쳐를 구현하기 위해서는 역활을 세분화합니다.
- 비즈니스 계층에 서비스를 배치해 엔티티와 같은 도메인 객체의 비즈니스 로직을 조합하도록 하고 데이터 접근 계층에는 DAo (Spring Data JPA 에서는 Repository ) 를 배치해 도메인을 관리합니다.

- 스프링의 레이어드 아키텍쳐는 다음과 같이 설명할 수 있습니다.
### 프레젠테이션 계층
- 상황에 따라 유저 인터페이스 계층 이라 부른다.
- 클라이언트와 접점이 된다.
- 클라이언트로 부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달받는 역활

### 비즈니스 계층
- 상황에 따라 서비스(Service) 계층이라고 합니다.
- 핵심 비즈니스 로직을 구현하는 영역
- 트랜잭션 처리나 유효성 검사 등의 작업도 수행

### 데이터 접근 계층
- 상황에 따라 영속(Persistence) 계층이라고 합니다.
- DB 접근해야 하는 작업을 수행
- 